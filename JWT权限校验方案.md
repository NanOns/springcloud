## JWT权限校验


### 经典的微服务权限验证解决方案
1.单点登录（SSO）方案
```
采用单点登录方案，意味着每个面向用户的服务都必须与认证服务交互，
这会产生大量非常琐碎的网络流量，同时这个防范实现起来也相当的复杂。
在其他方面，选择SSO方案安全性会很好，

用户登录状态是不透明的，可防止攻击者从状态中推断任何有用的信息。
```
2.分布式会话方案(redis存储session)
```
优点:
原理主要是将关于用户信息存储在共享内存中，并通常由用户会话作为key来实现简单的分布式哈希映射。
当用户访问微服务时，用户数据可以从共享存储中获取。
该方案的另外一个优点就是: 用户登录状态不是透明的。

缺点:高度依赖第三方redis的稳定性
```

3.token客户端令牌方案
```
优点:
此令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可以在所有微服务中建立用户身份。
令牌会附加到每一个请求上，为微服务提供身份验证。

缺点:
这种解决方案安全性相对较好，但身份验证注销是一个大大的问题，
缓解这种情况的方法可以使用短期令牌access_token 和频繁检查认证服务器等。

```

4.客户端令牌与API网关结合(JWT)
```
优点:
这个方案意味着所有的请求都通过网关，从而有效地隐藏了微服务。
在请求时，网关将原始用户令牌转换为内部会话（session）ID令牌。
在这种情况下，注销就不在是个大大的问题, 因为网关在注销时可以撤销用户的令牌

缺点:
实现相对复杂

```

#### 基于JWT 验证时序图
![输入图片说明](https://github.com/qccr-twl2123/livtrip/blob/master/src/main/resources/static/resources/images/JWT时序.png "在这里输入图片标题")


#### JWT认证原理简介
```
1.认证流程

客户端调用登录接口（或者获取 token 接口），传入用户名密码。
服务端请求身份认证中心，确认用户名密码正确。
服务端创建 JWT，返回给客户端。
客户端拿到 JWT，进行存储（可以存储在缓存中，也可以存储在数据库中，
如果是浏览器，可以存储在 Cookie 中）在后续请求中，在 HTTP 请求头中加上 JWT。
服务端校验 JWT，校验通过后，返回相关资源和数据。


2.JWT结构
JWT 是由三段信息构成的:
第一段为头部（Header），
第二段为载荷（Payload)，
第三段为签名（Signature）。

每一段内容都是一个 JSON 对象，将每一段 JSON 对象采用 BASE64 编码，将编码后的内容用.
链接一起就构成了 JWT 字符串

1.Header头部
头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。
{
"typ": "JWT",
"alg": "HS256"
}


2.Payload载荷
喜欢  | 作者 王海龙 
发布于 2017年8月9日. 估计阅读时间: 1 分钟 | 硅谷人工智能、机器学习、互联网金融、未来移动技术架构 ，尽在QCon上海2017 2  讨论
分享到：微博微信FacebookTwitter有道云笔记邮件分享稍后阅读我的阅读清单
从单体应用架构到分布式应用架构再到微服务架构，应用的安全访问在不断的经受考验。为了适应架构的变化、需求的变化，身份认证与鉴权方案也在不断的变革。面对数十个甚至上百个微服务之间的调用，如何保证高效安全的身份认证？面对外部的服务访问，该如何提供细粒度的鉴权方案？本文将会为大家阐述微服务架构下的安全认证与鉴权方案。

单体应用 VS 微服务

随着微服务架构的兴起，传统的单体应用场景下的身份认证和鉴权面临的挑战越来越大。单体应用体系下，应用是一个整体，一般针对所有的请求都会进行权限校验。请求一般会通过一个权限的拦截器进行权限的校验，在登录时将用户信息缓存到 session 中，后续访问则从缓存中获取用户信息。



而微服务架构下，一个应用会被拆分成若干个微应用，每个微应用都需要对访问进行鉴权，每个微应用都需要明确当前访问用户以及其权限。尤其当访问来源不只是浏览器，还包括其他服务的调用时，单体应用架构下的鉴权方式就不是特别合适了。在为服务架构下，要考虑外部应用接入的场景、用户 - 服务的鉴权、服务 - 服务的鉴权等多种鉴权场景。



David Borsos 在伦敦的微服务大会上提出了四种方案：

相关厂商内容

这可能是最好的技术内容搜索引擎
C++之父眼中编程语言的未来 gRPC在Rust中的应用 深入浅出Kotlin实践 京东硅谷研究院如何进行自动深度语法分析
相关赞助商

 
与100+国内外技术专家探索2017前瞻热点技术

1. 单点登录（SSO）

这种方案意味着每个面向用户的服务都必须与认证服务交互，这会产生大量非常琐碎的网络流量和重复的工作，当动辄数十个微应用时，这种方案的弊端会更加明显。

2. 分布式 Session 方案

分布式会话方案原理主要是将关于用户认证的信息存储在共享存储中，且通常由用户会话作为 key 来实现的简单分布式哈希映射。当用户访问微服务时，用户数据可以从共享存储中获取。在某些场景下，这种方案很不错，用户登录状态是不透明的。同时也是一个高可用且可扩展的解决方案。这种方案的缺点在于共享存储需要一定保护机制，因此需要通过安全链接来访问，这时解决方案的实现就通常具有相当高的复杂性了。

3. 客户端 Token 方案

令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可以在所有微服务中建立用户身份。令牌会附加到每个请求上，为微服务提供用户身份验证，这种解决方案的安全性相对较好，但身份验证注销是一个大问题，缓解这种情况的方法可以使用短期令牌和频繁检查认证服务等。对于客户端令牌的编码方案，Borsos 更喜欢使用 JSON Web Tokens（JWT），它足够简单且库支持程度也比较好。

4. 客户端 Token 与 API 网关结合

这个方案意味着所有请求都通过网关，从而有效地隐藏了微服务。 在请求时，网关将原始用户令牌转换为内部会话 ID 令牌。在这种情况下，注销就不是问题，因为网关可以在注销时撤销用户的令牌。

微服务常见安全认证方案

HTTP 基本认证

HTTP Basic Authentication（HTTP 基本认证）是 HTTP 1.0 提出的一种认证机制，这个想必大家都很熟悉了，我不再赘述。HTTP 基本认证的过程如下：

客户端发送 HTTP Request 给服务器。
因为 Request 中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 Header "WWW-Authenticate" 中添加信息。
客户端把用户名和密码用 BASE64 加密后，放在 Authorization Header 中发送给服务器， 认证成功。
服务器将 Authorization Header 中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端。
基于 Session 的认证

基于 Session 的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到 Session 中，单体应用架构中，默认 Session 会存储在应用服务器中，并且将 Session ID 返回到客户端，存储在浏览器的 Cookie 中。

但是在分布式架构下，Session 存放于某个具体的应用服务器中自然就无法满足使用了，简单的可以通过 Session 复制或者 Session 粘制的方案来解决。

Session 复制依赖于应用服务器，需要应用服务器有 Session 复制能力，不过现在大部分应用服务器如 Tomcat、JBoss、WebSphere 等都已经提供了这个能力。

除此之外，Session 复制的一大缺陷在于当节点数比较多时，大量的 Session 数据复制会占用较多网络资源。Session 粘滞是通过负载均衡器，将统一用户的请求都分发到固定的服务器节点上，这样就保证了对某一用户而言，Session 数据始终是正确的。不过这种方案依赖于负载均衡器，并且只能满足水平扩展的集群场景，无法满足应用分割后的分布式场景。

在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将 Session 从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如 Memchached、Redis 等。这正是 David Borsos 建议的第二种方案，分布式 Session 方案。



基于 Token 的认证

随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session ID 不同，并非只是一个 key。Token 一般会包含用户的相关信息，通过验证 Token 就可以完成身份校验。像 Twitter、微信、QQ、GitHub 等公有服务的 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。基于 Token 认证的一个典型流程如下：



用户输入登录信息（或者调用 Token 接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。
身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在 Session 或者数据库中。
用户将 Token 放在 HTTP 请求头中，发起相关 API 调用。
被调用的微服务，验证 Token 权限。
服务端返回相关资源和数据。
基于 Token 认证的好处如下：

服务端无状态：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有用户的相关信息。
性能较好，因为在验证 Token 时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。
支持移动设备。
支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。
下面会重点介绍两种基于 Token 的认证方案 JWT/Oauth2.0。

JWT 介绍

JSON Web Token（JWT）是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。来自 JWT RFC 7519 标准化的摘要说明：JSON Web Token 是一种紧凑的，URL 安全的方式，表示要在双方之间传输的声明。JWT 一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 Token 也可直接被用于认证，也可被加密。

JWT 认证流程

客户端调用登录接口（或者获取 token 接口），传入用户名密码。
服务端请求身份认证中心，确认用户名密码正确。
服务端创建 JWT，返回给客户端。
客户端拿到 JWT，进行存储（可以存储在缓存中，也可以存储在数据库中，如果是浏览器，可以存储在 Cookie 中）在后续请求中，在 HTTP 请求头中加上 JWT。
服务端校验 JWT，校验通过后，返回相关资源和数据。
JWT 结构

JWT 是由三段信息构成的，第一段为头部（Header），第二段为载荷（Payload)，第三段为签名（Signature）。每一段内容都是一个 JSON 对象，将每一段 JSON 对象采用 BASE64 编码，将编码后的内容用. 链接一起就构成了 JWT 字符串。如下：

header.payload.signature

1. 头部（Header）

头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个 JSON 对象。

{
"typ": "JWT",
"alg": "HS256"
}
在头部指明了签名算法是 HS256 算法。

2. 载荷（payload）

载荷就是存放有效信息的地方。有效信息包含三个部分：
标准中注册的声明
公共的声明
私有的声明

标准中注册的声明（建议但不强制使用）：
iss：JWT 签发者
sub：JWT 所面向的用户
aud：接收 JWT 的一方
exp：JWT 的过期时间，这个过期时间必须要大于签发时间
nbf：定义在什么时间之前，该 JWT 都是不可用的
iat：JWT 的签发时间
jti：JWT 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。

示例代码:

{ "iss": "Online JWT Builder",
 "iat": 1416797419,
 "exp": 1448333419,
 "aud": "www.primeton.com",
 "sub": "devops@primeton.com",
 "GivenName": "dragon",
 "Surname": "wang",
 "admin": true
}

3.Signature签名
创建签名需要使用 Base64 编码后的 header 和 payload 以及一个秘钥。
将 base64 加密后的 header 和 base64 加密后的 payload 使用. 连接组成的字符串，
通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。

比如：HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

JWT 的优点：
跨语言，JSON 的格式保证了跨语言的支撑
基于 Token，无状态
占用字节小，便于传输


```
#### JWT实施步骤

```
Maven依赖:
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.6.0</version>
</dependency>



```




参考博客:

http://www.infoq.com/cn/articles/identity-authentication-of-architecture-in-micro-service













